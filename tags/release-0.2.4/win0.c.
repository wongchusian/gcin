#include "gcin.h"

static char *font_name="8x16";
static char *cfont_name="taipei16";
static XFontStruct *afont, *cfont;
int fwidth, fheight;
static PangoFontDescription* pango_font;

static gboolean gray_style = 1, large_font = 1;

static struct {
  u_long fg, bg;
  char *fg_str,*bg_str;
  GdkColor color;
} pc_color[]= {
  {0,0,"white","blue"},
  {0,0,"yellow","brown"},
  {0,0,"red","yellow"},
  {0,0,"blue","blue"}
};

static Colormap colormap;
static int screen_no;
static long foreground, background;
int win_xl, win_yl, win_x, win_y;

int dpy_xl;
int dpy_yl;

static void alloc_pc_colors()
{
  XColor color;
  int i;

  if (gray_style) {
    pc_color[0].fg_str = "black";
    pc_color[0].bg_str = "gray";
    pc_color[3].fg_str = pc_color[3].bg_str = "white";
  }

  screen_no = DefaultScreen(dpy);
  colormap = DefaultColormap(dpy,screen_no);

  for(i=0; i<sizeof(pc_color)/sizeof(pc_color[0]); i++) {
    if (!XParseColor(dpy, colormap,pc_color[i].fg_str, &color))
            p_err("invalid color %s",pc_color[i].fg_str);
    if (!XAllocColor(dpy, colormap,&color))
            p_err("can't allocate color %s",pc_color[i].fg_str);
            pc_color[i].fg=color.pixel;
    if (!XParseColor(dpy, colormap,pc_color[i].bg_str, &color))
            p_err("invalid color %s",pc_color[i].bg_str);
    if (!XAllocColor(dpy, colormap,&color))
            p_err("can't allocate color %s",pc_color[i].bg_str);
            pc_color[i].bg=color.pixel;
  }

  foreground=pc_color[0].fg;
  background=pc_color[0].bg;
}

static void load_font()
{
  if (large_font) {
    font_name = "12x24";
    cfont_name = "taipeim24";
  }

  if (afont) XFreeFont(dpy, afont);
  if (!(afont=XLoadQueryFont(dpy, font_name)))
    p_err("Cannot load ascii font %s", font_name);

  fwidth = afont->max_bounds.width;
  fheight = afont->ascent + afont->descent;

  if (cfont) XFreeFont(dpy, cfont);
  if (!(cfont=XLoadQueryFont(dpy, cfont_name)))
    p_err("Cannot load big5 font %s", cfont_name);

  pango_font=pango_context_get_font_description
                             (gtk_widget_get_pango_context (gwin0));

  dbg("pango_font: %x\n", pango_font);
}

static GC gc,cgc;

static void create_gc()
{
  XGCValues gcv;

  gcv.foreground = foreground;
  gcv.background = background;
  gcv.graphics_exposures = False;
  gcv.font=afont->fid;

  if (gc)
    XFreeGC(dpy,gc);
  gc = XCreateGC(dpy, xwin0,GCForeground|GCBackground|GCFont|
                 GCGraphicsExposures,&gcv);

  if (!gc)
    p_err("gc not created");

  gcv.font = cfont->fid;
  if (cgc)
    XFreeGC(dpy, cgc);

  cgc = XCreateGC(dpy, xwin0,GCForeground|GCBackground|GCFont|
                  GCGraphicsExposures,&gcv);

  if (!cgc)
    p_err("cgc not created");
}

static void restore();

GtkWidget *gwin0;
GdkWindow *gdkwin0;
Window xwin0;

#define DBGXEVE (0)

static gboolean VisibilityNotify_event(GtkWidget *widget, GdkEvent *event,
                                       gpointer user_data)
{
     if (!xwin0)
       return TRUE;

     GdkEventVisibility *peve=&event->visibility;
#if DBGXEVE
      dbg("VisibilityNotify: %d ",peve->state);
#endif
      if(peve->state == GDK_VISIBILITY_FULLY_OBSCURED) {
#if DBGXEVE
        dbg("FO\n");
#endif
      } else
      if(peve->state == GDK_VISIBILITY_UNOBSCURED) {
#if DBGXEVE
        dbg("U\n");
#endif
        restore();
      } else {
#if DBGXEVE
        dbg("PO\n");
#endif
//        restore();
      }

      return TRUE;
}

void destory_win1();
void free_tsin();
void free_all_IC();

void do_exit()
{
  dbg("----------------- do_ exit ----------------\n");

  free_pho_mem();
  free_tsin();
  free_all_IC();

#if 1
  gtk_widget_destroy(gwin0);
  destory_win1();
#endif

  gtk_main_quit();
}

static void mouse_button_callback( GtkWidget *widget,GdkEventButton *event, gpointer data)
{
  int x=event->x;
  int y=event->y;

//  dbg("mouse_button_callback %d\n", event->button);

  switch (event->button) {
    case 1:
      create_win_sym();
      break;
    case 2:
      break;
    case 3:
      dbg("exec gcin\n");
      system("gcin-setup &");
      break;
  }

}


void load_colors_fonts()
{
  gray_style = get_gcin_conf_int("main-win-gray-style", 0);
  large_font = get_gcin_conf_int("main-win-large-font", 0);

  alloc_pc_colors();
  load_font();
}



static pref_sizeX, pref_sizeY;
static GtkWidget *label_pho;

void create_win0()
{
  load_colors_fonts();

  gwin0 = gtk_window_new (GTK_WINDOW_TOPLEVEL);

  GtkStyle *style = gtk_widget_get_style (gwin0);

  gtk_widget_set_events(gwin0,
      GDK_EXPOSURE_MASK|GDK_VISIBILITY_NOTIFY_MASK|GDK_BUTTON_PRESS_MASK);

  pref_sizeX=fwidth*12;  pref_sizeY=fheight*MROW + ROW_ROW_SPACING;

  gtk_window_set_default_size(GTK_WINDOW (gwin0), pref_sizeX, pref_sizeY);

  gtk_widget_set_double_buffered (gwin0, FALSE);
  gtk_widget_set_app_paintable (gwin0, TRUE);


  gtk_widget_realize (gwin0);
  gdkwin0 = gwin0->window;
  xwin0 = GDK_WINDOW_XWINDOW(gdkwin0);

  gdk_window_set_override_redirect(gdkwin0, TRUE);

  dpy_xl = gdk_screen_width();
  dpy_yl = gdk_screen_height();

  create_gc();

  g_signal_connect(G_OBJECT(gwin0),"visibility-notify-event",
       G_CALLBACK(VisibilityNotify_event), NULL);

  g_signal_connect (G_OBJECT (gwin0), "delete_event",
                    G_CALLBACK (do_exit), NULL);

  g_signal_connect(G_OBJECT(gwin0),"button-press-event",
                   G_CALLBACK(mouse_button_callback), NULL);

  GdkColor color;
  char *bg_color = "blue";

  if (gray_style)
    bg_color = "gray";

  gdk_color_parse(bg_color, &color);

  gtk_widget_modify_bg(gwin0, GTK_STATE_NORMAL, &color);

  gtk_window_get_size(GTK_WINDOW(gwin0), &win_xl, &win_yl);

  GdkCursor* cursor = gdk_cursor_new (GDK_HAND2);
  gdk_window_set_cursor(gdkwin0, cursor);
}

#define MCOLX (120)

static u_char tch[MROW][MCOLX];  /* store text */
static u_char tat[MROW][MCOLX];	/* color attribute */
static u_char tby[MROW][MCOLX];  /* indicate if it is a chinese ch */

void get_win_pix_x_y(int x, int y, int *px, int *py)
{
  *px = x * fwidth;
  *py = y*fheight + afont->ascent;

  if (y)
    *py+=ROW_ROW_SPACING;
}

static void ostr_draw(int x, int y, char *str, int len, u_char att)
{
  int ix,iy;
  u_long fg,bg;

  get_win_pix_x_y(x, y, &ix, &iy);

  fg=pc_color[att&0xf].fg;
  bg=pc_color[att&0xf].bg;
  XSetForeground(dpy, gc, fg);
  XSetBackground(dpy, gc, bg);
  XDrawImageString(dpy, xwin0, gc, ix,iy, str, len);
}


static void ostr(int x, int y, char *str, int len, u_char att)
{
  int ix,iy;
  u_long fg,bg;

  if (!len)
    len=strlen(str);

  memcpy(&tch[y][x], str, len);
  memset(&tat[y][x], att, len);
  bzero(&tby[y][x], len);

  ostr_draw(x, y, str, len, att);
}


static void costr_draw(int x, int y, char *str, int len, u_char att)
{
  int ix,iy;
  u_long fg,bg;

  get_win_pix_x_y(x, y, &ix, &iy);

  fg=pc_color[att&0xf].fg;
  bg=pc_color[att&0xf].bg;

  XSetForeground(dpy, cgc, fg);
  XSetBackground(dpy, cgc, bg);
  XDrawImageString16(dpy, xwin0, cgc, ix,iy, (XChar2b *)str, len>>1);
}


static void costr(int x, int y, char *str, int len, u_char att)
{
  int ix,iy;
  int i;
  u_char *bp=&tby[y][x];
  u_char *cp=&tat[y][x];
  u_long fg,bg;

  if (!len)
    len=strlen(str);

  memcpy(&tch[y][x], str, len);
  memset(&tat[y][x], att, len);
  for(i=0;i<len;i++)
     *(bp+i)= ((i&1)?0x20:0x40);             /* 0:asc  0x20:CH1   0x40:CH2 */

  costr_draw(x, y, str, len, att);
}

static void restore()
{
  int y;
  u_char catt,cbyte;
  u_char *p,*q;
  int stx;
  int len;

  for(y=0;y<MROW;y++) {
    p=&tat[y][0];
    q=&tby[y][0];
    stx=0;
    len=0;
    catt=*p;
    cbyte=*q;

    while (stx < MCOL) {
      if (cbyte & 0x60) cbyte|=0x60;
      while (catt==*p && cbyte==(*q&0x60?*q|0x60:*q) && len+stx<MCOL ) {
          len++; p++; q++;
      }

      if (cbyte & 0x60)
        costr_draw(stx, y, &tch[y][stx], len, catt);
      else
        ostr_draw(stx, y, &tch[y][stx], len, catt);

      stx+=len;
      len=0;
      catt=*p;
      cbyte=*q;
    }
  }
}

static xputs(int x, int y, u_char *s, u_char att)
{
  u_char ch;
  int len=strlen(s);
  int cl=0;
  u_char *cp, *endp, *strp;
  char ctyp;
  u_char hb,lb;

//  dbg("xputs: %d %d '%s' %d\n", x,y, s, att);
  strp=cp=s;
  endp=s+len;
  cl=0;
  ctyp=0;

  while (cp<endp) {
    hb=*cp;
    if ((hb>=0x81&&hb<=0xfe) && cp+1<endp) {
      lb=*(cp+1);
      if (lb>=0x40&&lb<=0x7e || lb>=0xa1&&lb<=0xfe) {
        if (ctyp==1) {
          ostr(strp-s+x,y,strp,cl,att);
          cl=0;
          strp=cp;
        }
        cl+=2;
        cp+=2;
        ctyp=2;
        continue;
      }
    }
    if (ctyp==2) {
      costr(strp-s+x,y,strp,cl,att);
      cl=0;
      strp=cp;
    }
    cl++;
    cp++;
    ctyp=1;
  }

  if (ctyp==1)
    ostr(strp-s+x,y,strp,cl,att);
  if (ctyp==2)
    costr(strp-s+x,y,strp,cl,att);
}

void draw_line(int att, int x0, int y0, int x1, int y1)
{
  u_long fg=pc_color[att&0xf].fg;
  XSetForeground(dpy, gc, fg);
  XDrawLine(dpy, xwin0, gc, x0, y0, x1, y1);
}


int cursor_x=0, cursor_y=0;
static u_char cur_att;
void xprintf(char *fmt, ...)
{
  va_list args;
  char tmp[100];

  va_start(args, fmt);
  vsprintf(tmp, fmt, args);
  va_end(args);
  xputs(cursor_x, cursor_y, tmp, cur_att);
  cursor_x+=strlen(tmp);
}

void gotoxy(int x, int y)
{
  cursor_x=x;
  cursor_y=y;
}
void set_att(u_char att)
{
  cur_att=att;
}

int visual_bell=0;
void bell()
{
  if (visual_bell) {
    XClearWindow(dpy, xwin0);
    XFlush(dpy);
    usleep(100000);
    restore();
  }
  else
    XBell(dpy, 50);
}

void ClrSelArea()
{
//  dbg("ClrSelArea\n");
  int i;

  gotoxy(0,0);
  for(i=0;i<MCOL;i++)
    xprintf(" ");

  gotoxy(0,0);
}

void hide_win_sym();
void hide_win0()
{
  gtk_widget_hide(gwin0);
  hide_selections_win();
  hide_win_sym();
}


void show_win_sym();
void show_win0()
{
  gtk_widget_show(gwin0);
  gtk_window_get_position(GTK_WINDOW(gwin0), &win_x, &win_y);
  show_win_sym();
}

void move_win0(int x, int y)
{
  gtk_window_get_size(GTK_WINDOW(gwin0), &win_xl, &win_yl);

  if (x + win_xl > dpy_xl)
    x = dpy_xl - win_xl;
  if (x < 0)
    x = 0;

  if (y + win_yl > dpy_yl)
    y = dpy_yl - win_yl;
  if (y < 0)
    y = 0;

  win_x = x;  win_y = y;
  gtk_window_move(GTK_WINDOW(gwin0), x, y);
}


void resize_win0(int c_xlen)
{
  win_xl = fwidth*c_xlen;
  gtk_window_resize(GTK_WINDOW(gwin0), win_xl, win_yl);
  gtk_window_get_size(GTK_WINDOW(gwin0), &win_xl, &win_yl);

  int nwin_x=win_x, nwin_y=win_y;

  if (win_x + win_xl > dpy_xl)
    nwin_x = dpy_xl - win_xl;
  if (win_y + win_yl > dpy_yl)
    nwin_y = dpy_yl - win_yl;

  if (nwin_x != win_x || nwin_y != win_y)
    move_win0(nwin_x, nwin_y);
}
